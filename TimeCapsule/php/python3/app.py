#!/home/shi/anaconda3/bin/python
# -*- encoding: utf-8 -*-
import os
import sys
from flask import *
from flask_cors import CORS
import base64
from PIL import Image
from io import BytesIO
from src.inpainting import InpaintNet, EdgeNet, InputImages
import numpy as np
import torch


app = Flask(__name__, template_folder='.')
cors = CORS(app)

#create NN
device = "cuda:0" if torch.cuda.is_available() else "cpu"
#edge_net creates an edge containing a masked part from a masked image, the edges of the masked image and the image of the mask only
edge_net = EdgeNet().to(device)
edge_net.load_state_dict(edge_net.weight['generator'])

#inpait_net creates a repaired image from the masked image and the edge image generated by edge_net
inpaint_net = InpaintNet().to(device)
inpaint_net.load_state_dict(inpaint_net.weight['generator'])

@app.route('/')
def index():
    #return "Hello World"
    return render_template("index.html")


@app.route('/send_img', methods=['POST'])
def inpaiting():

    # Receive image data and decode
    enc_original = request.get_json()['img1']
    enc_mask = request.get_json()['img2']
    dec_original = base64.b64decode(enc_original.split(',')[1])
    dec_mask = base64.b64decode(enc_mask.split(',')[1])

    # I wanted to resize with JS to reduce the transmission capacity, but it does not work well, so resize on the server side once
    img_original = Image.open(BytesIO(dec_original))
    img_original = img_original.resize((512, 512))
    img_mask = Image.open(BytesIO(dec_mask))
    img_mask = img_mask.resize((512, 512))

    # Mask the image. (paint image)
    c = Image.new('RGBA', img_original.size, (255, 255, 255, 0))
    c.paste(img_mask, (0, 0), img_mask)
    img_masked = Image.alpha_composite(img_original, c)
    img_masked = img_masked.convert("RGB")
    img_mask = img_mask.convert("RGB")

    # inpaining process
    img_setting = InputImages(np.array(img_masked)/255, np.array(img_mask)/255)
    output_edge = edge_net(img_setting.input_edgenet().float())
    output_inpaint = inpaint_net(img_setting.input_inpaintnet(output_edge).float()).detach().numpy()
    output_inpaint = (output_inpaint * 255).astype(np.uint8).transpose(0, 2, 3, 1)
    result_img = Image.fromarray(output_inpaint.reshape(512, 512, 3))


    # Decoding process of generated image and original image
    buffer = BytesIO()
    img_original.save(buffer, format="PNG")
    base64Img_original = base64.b64encode(buffer.getvalue()).decode("utf-8").replace("'", "")
    base64Img_original = "data:image/png;base64,{}".format(base64Img_original)

    buffer = BytesIO()
    result_img.save(buffer, format="PNG")
    base64Img_result = base64.b64encode(buffer.getvalue()).decode("utf-8").replace("'", "")
    base64Img_result = "data:image/png;base64,{}".format(base64Img_result)

    res = {
        'ip_type': 'inpaint_success',
        'result': base64Img_result,
        'original': base64Img_original
    }

    return jsonify(ResultSet=res)

if __name__ == '__main__':
	#app.run(host="0.0.0.0")
	#app.run(host='127.0.0.1', port='57166', debug=True)
	#app.run(host='tec2.hpc.temple.edu', port='57166', debug=True)
	#app.run(host="tec2.hpc.temple.edu", debug=False)
	app.run(host="0.0.0.0", debug=False, port="57166")
